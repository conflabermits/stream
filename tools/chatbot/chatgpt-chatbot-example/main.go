// Generated by ChatGPT and Gemini, mostly

package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"os/signal"
	"sort"
	"strings"
	"syscall"
	"time"
	"unicode"
	"unicode/utf8"

	"github.com/gempir/go-twitch-irc/v4"
)

func getEnvVar(key string) string {
	value, exists := os.LookupEnv(key)
	if !exists {
		fmt.Printf("Error: Environment variable %s is not set\n", key)
		os.Exit(1)
	}
	return value
}

type PollReqData struct {
	// Define your data structure here
	BroadcasterId              string       `json:"broadcaster_id"`
	PollTitle                  string       `json:"title"`
	Choices                    []PollChoice `json:"choices"`
	ChannelPointsVotingEnabled bool         `json:"channel_points_voting_enabled"`
	ChannelPointsPerVote       int          `json:"channel_points_per_vote"`
	Duration                   int          `json:"duration"`
}

type PollChoice struct {
	Title string `json:"title"`
}

func sendPoll(question string, choice1 string, choice2 string) {
	// Define your URL and data
	url := "https://api.twitch.tv/helix/polls"
	data := PollReqData{
		BroadcasterId: "426422677",
		PollTitle:     question,
		Choices: []PollChoice{
			{Title: choice1},
			{Title: choice2},
		},
		ChannelPointsVotingEnabled: true,
		ChannelPointsPerVote:       100,
		Duration:                   120,
	}

	// Marshal the data to JSON
	jsonData, err := json.Marshal(data)
	if err != nil {
		fmt.Println("Error marshalling JSON:", err)
		return
	}

	// Create a new POST request
	req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonData))
	if err != nil {
		fmt.Println("Error creating request:", err)
		return
	}

	// Set the Content-Type header
	bearerToken := strings.Split(getEnvVar("twitchToken"), ":")[1]
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+bearerToken)
	req.Header.Set("Client-Id", getEnvVar("clientId"))

	// -H "Authorization: Bearer ${twitchToken}" -H "Client-Id: ${clientId}"

	// Send the request with a client
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		fmt.Println("Error sending request:", err)
		return
	}
	defer resp.Body.Close()

	// Optionally, handle the response
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		fmt.Println("Error reading response body:", err)
		return
	}

	fmt.Println("Response status:", resp.StatusCode)
	fmt.Println("Response body:", string(body))
}

// Borrowed code for better alphabetizer, case insensitive!
// https://programming-idioms.org/idiom/297/sort-a-list-of-strings-case-insensitively/5458/go

func lessCaseInsensitive(s, t string) bool {
	for {
		if len(t) == 0 {
			return false
		}
		if len(s) == 0 {
			return true
		}
		c, sizec := utf8.DecodeRuneInString(s)
		d, sized := utf8.DecodeRuneInString(t)

		lowerc := unicode.ToLower(c)
		lowerd := unicode.ToLower(d)

		if lowerc < lowerd {
			return true
		}
		if lowerc > lowerd {
			return false
		}

		s = s[sizec:]
		t = t[sized:]
	}
}

func alphabetize(message string) string {
	words := strings.Fields(message)
	sort.Slice(words, func(i, j int) bool { return lessCaseInsensitive(words[i], words[j]) })
	result := strings.Join(words, " ")
	return result
}

// Borrowed some code from Twilio's example for getting inspirational quotes
// https://www.twilio.com/blog/inspire-your-friends-using-go-twilio-messaging

type Response struct {
	Status     string
	StatusCode int
	Method     string
	Body       []byte
}

type ZenQuotes struct {
	Quote  string `json:"q"`
	Author string `json:"a"`
}

func getQuote() string {
	response, err := sendRequest()
	if err != nil {
		log.Fatal(err)
	}

	var message ZenQuotes
	msg := []ZenQuotes{{
		message.Author,
		message.Quote,
	}}

	err = json.Unmarshal(response.Body, &msg)
	if err != nil {
		log.Fatal(err)
	}
	return msg[0].Quote
}

func sendRequest() (*Response, error) {
	r := &Response{}

	httpClient := &http.Client{Timeout: 20 * time.Second}
	zenQuotesUrl := "https://zenquotes.io/api/random"

	req, err := http.NewRequest(http.MethodGet, zenQuotesUrl, nil)
	if err != nil {
		return nil, err
	}

	response, err := httpClient.Do(req)
	if err != nil {
		return nil, err
	}

	defer response.Body.Close()

	body, err := io.ReadAll(response.Body)
	if err != nil {
		return nil, err
	}

	r.Status = response.Status
	r.StatusCode = response.StatusCode
	r.Body = body

	return r, nil
}

func main() {
	// Set your Twitch username, OAuth token, and channel to join
	//username := "your_twitch_username"
	//token := "your_oauth_token"
	//channel := "channel_to_join"
	username := getEnvVar("twitchUsername") //e.g., "conflabermits"
	token := getEnvVar("twitchToken")       //e.g., "oauth:<token>"
	channel := getEnvVar("twitchChannel")   //e.g., "conflabermits"

	// Create a new Twitch client
	client := twitch.NewClient(username, token)

	// Register a callback for when the bot receives a message
	client.OnPrivateMessage(func(message twitch.PrivateMessage) {
		// Print the message to the console
		fmt.Printf("[%s] %s: %s\n", message.Channel, message.User.DisplayName, message.Message)

		// You can add your own logic here to respond to messages
		// For example, you can check for specific commands and reply accordingly
		if message.Message == "!hello" || message.Message == "!hellobot" {
			log.Println("Detected !hello message")
			client.Say(message.Channel, "Hello, "+message.User.DisplayName+"!")
		}
		if message.Message == "!bye" || message.Message == "!byebot" {
			log.Println("Detected !bye message")
			client.Say(message.Channel, "Goodbye, "+message.User.DisplayName+"! I'll miss you!")
		}
		if strings.HasPrefix(message.Message, "!abc ") || strings.HasPrefix(message.Message, "!alpha ") {
			log.Println("Detected !abc message")
			commandText := strings.TrimPrefix(message.Message, "!abc ")
			client.Say(message.Channel, alphabetize(commandText))
		}
		// Command ideas:
		// !randomize - Randomize the words from the message
		if message.Message == "!quote" || message.Message == "!randomquote" {
			log.Println("Detected !quote message")
			client.Say(message.Channel, "Random quote -- "+getQuote()+".. in bed.")
		}
		if message.Message == "!poll" {
			log.Println("Detected !poll message")
			client.Say(message.Channel, "Creating a poll for you!")
			//pollText := strings.TrimPrefix(message.Message, "!poll ")
			//words := strings.Fields(str)
			sendPoll("question", "answer1", "answer2")
		}
	})

	client.OnConnect(func() { client.Say(channel, "Let's GOOOOOO!") })

	// Join the specified channel
	client.Join(channel)

	// Connect to Twitch IRC
	err := client.Connect()
	if err != nil {
		log.Fatal(err)
	}

	// Wait for a signal to gracefully shut down the bot
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)
	<-sigChan

	// Disconnect from Twitch IRC on shutdown
	client.Disconnect()
}
