// Generated by ChatGPT, mostly

package main

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"os/signal"
	"sort"
	"strings"
	"syscall"
	"time"
	"unicode"
	"unicode/utf8"

	"github.com/gempir/go-twitch-irc/v4"
)

func getEnvVar(key string) string {
	value, exists := os.LookupEnv(key)
	if !exists {
		fmt.Printf("Error: Environment variable %s is not set\n", key)
		os.Exit(1)
	}
	return value
}

// Borrowed code for better alphabetizer, case insensitive!
// https://programming-idioms.org/idiom/297/sort-a-list-of-strings-case-insensitively/5458/go

func lessCaseInsensitive(s, t string) bool {
	for {
		if len(t) == 0 {
			return false
		}
		if len(s) == 0 {
			return true
		}
		c, sizec := utf8.DecodeRuneInString(s)
		d, sized := utf8.DecodeRuneInString(t)

		lowerc := unicode.ToLower(c)
		lowerd := unicode.ToLower(d)

		if lowerc < lowerd {
			return true
		}
		if lowerc > lowerd {
			return false
		}

		s = s[sizec:]
		t = t[sized:]
	}
}

func alphabetize(message string) string {
	words := strings.Fields(message)
	sort.Slice(words, func(i, j int) bool { return lessCaseInsensitive(words[i], words[j]) })
	result := strings.Join(words, " ")
	return result
}

// Borrowed some code from Twilio's example for getting inspirational quotes
// https://www.twilio.com/blog/inspire-your-friends-using-go-twilio-messaging

type Response struct {
	Status     string
	StatusCode int
	Method     string
	Body       []byte
}

type ZenQuotes struct {
	Quote  string `json:"q"`
	Author string `json:"a"`
}

func getQuote() string {
	response, err := sendRequest()
	if err != nil {
		log.Fatal(err)
	}

	var message ZenQuotes
	msg := []ZenQuotes{{
		message.Author,
		message.Quote,
	}}

	err = json.Unmarshal(response.Body, &msg)
	if err != nil {
		log.Fatal(err)
	}
	return msg[0].Quote
}

func sendRequest() (*Response, error) {
	r := &Response{}

	httpClient := &http.Client{Timeout: 20 * time.Second}
	zenQuotesUrl := "https://zenquotes.io/api/random"

	req, err := http.NewRequest(http.MethodGet, zenQuotesUrl, nil)
	if err != nil {
		return nil, err
	}

	response, err := httpClient.Do(req)
	if err != nil {
		return nil, err
	}

	defer response.Body.Close()

	body, err := io.ReadAll(response.Body)
	if err != nil {
		return nil, err
	}

	r.Status = response.Status
	r.StatusCode = response.StatusCode
	r.Body = body

	return r, nil
}

func main() {
	// Set your Twitch username, OAuth token, and channel to join
	//username := "your_twitch_username"
	//token := "your_oauth_token"
	//channel := "channel_to_join"
	username := getEnvVar("twitchUsername") //e.g., "conflabermits"
	token := getEnvVar("twitchToken")       //e.g., "oauth:<token>"
	channel := getEnvVar("twitchChannel")   //e.g., "conflabermits"

	// Create a new Twitch client
	client := twitch.NewClient(username, token)

	// Register a callback for when the bot receives a message
	client.OnPrivateMessage(func(message twitch.PrivateMessage) {
		// Print the message to the console
		fmt.Printf("[%s] %s: %s\n", message.Channel, message.User.DisplayName, message.Message)

		// You can add your own logic here to respond to messages
		// For example, you can check for specific commands and reply accordingly
		if message.Message == "!hello" {
			log.Println("Detected !hello message")
			client.Say(message.Channel, "Hello, "+message.User.DisplayName+"!")
		}
		if message.Message == "!byebot" {
			log.Println("Detected !byebot message")
			client.Say(message.Channel, "Goodbye, "+message.User.DisplayName+"! I'll miss you!")
		}
		if strings.HasPrefix(message.Message, "!abc ") {
			log.Println("Detected !abc message")
			commandText := strings.TrimPrefix(message.Message, "!abc ")
			client.Say(message.Channel, alphabetize(commandText))
		}
		// Command ideas:
		// !randomize - Randomize the words from the message
		if message.Message == "!quote" {
			log.Println("Detected !quote message")
			client.Say(message.Channel, "Random quote -- "+getQuote()+".. in bed.")
		}
	})

	client.OnConnect(func() { client.Say("conflabermits", "Let's GOOOOOO!") })

	// Join the specified channel
	client.Join(channel)

	// Connect to Twitch IRC
	err := client.Connect()
	if err != nil {
		log.Fatal(err)
	}

	// Wait for a signal to gracefully shut down the bot
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)
	<-sigChan

	// Disconnect from Twitch IRC on shutdown
	client.Disconnect()
}
